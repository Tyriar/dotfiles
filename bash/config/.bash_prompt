git_prompt() {
	local branchName='';
	local git_arrows=""
	local change_summary=""

	# Check if the current directory is in a Git repository.
	if [ $(git rev-parse --is-inside-work-tree &>/dev/null; echo "${?}") == '0' ]; then

		# check if the current directory is in .git before running git checks
		if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == 'false' ]; then

			# Ensure the index is up to date.
			git update-index --really-refresh -q &>/dev/null;

			# Check upstream/downstream difference.
			local left="";
			local right="";
			if $(git rev-list --left-only --count HEAD...@'{u}' &>/dev/null); then
				left_output=$(git rev-list --left-only --count HEAD...@'{u}');
				if [ $left_output -gt 0 ]; then
					left="${left_output}⇡";
				fi
			fi;
			if $(git rev-list --right-only --count HEAD...@'{u}' &>/dev/null); then
				right_output=$(git rev-list --right-only --count HEAD...@'{u}');
				if [ $right_output -gt 0 ]; then
					right="${right_output}⇣";
				fi
			fi;
			if [ ! -z "$left" ]; then
				git_arrows+="\e[1;32m${left}"
			fi
			if [ ! -z "$right" ]; then
				git_arrows+="\e[1;31m${right}"
			fi
			if [ ! -z "$git_arrows" ]; then
				git_arrows="\e[1;30m[${git_arrows}\e[1;30m]"
			fi
			
			local file_summary_output=$(git diff --shortstat);
			local insertions=$(echo $file_summary_output | grep -o -E '([0-9]+ i)' | sed "s/ i//g");
			local deletions=$(echo $file_summary_output | grep -o -E '([0-9]+ d)' | sed "s/ d//g");
			
			if [ ! -z "$insertions" ]; then
				change_summary+="\e[0;2;32m+${insertions}"
				if [ ! -z "$deletions" ]; then
					change_summary+="\e[1;30m/"
				fi
			fi
			if [ ! -z "$deletions" ]; then
				change_summary+="\e[0;2;31m-${deletions}"
			fi
			
			# Check for untracked files.
			if [ -n "$(git ls-files --others --exclude-standard)" ]; then
				if [ ! -z "$insertions" ] || [ ! -z "$deletions" ]; then
					change_summary+="\e[1;30m/"
				fi
				change_summary+='\e[0;2;36m?';
			fi;
			if [ ! -z "$change_summary" ]; then
				change_summary=" ${change_summary}\e[0m"
			fi
		fi;

		# Get the short symbolic ref.
		# If HEAD isn’t a symbolic ref, get the short SHA for the latest commit
		# Otherwise, just give up.
		branchName="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
			git rev-parse --short HEAD 2> /dev/null || \
			echo '(unknown)')";

		echo -e "${1}\e[1;33m@${branchName}${git_arrows}${change_summary}"
	else
		return;
	fi;
}

PS1="\n";
PS1+="\[\e[01;34m\]\w\[\e[00m\]";
PS1+=" \$(git_prompt \"\[\e[1;35m\]\")\e[0m";
PS1+="\n";
PS1+="\[\e[1;32m\]"
PS1+="❯ \[\e[0m\]";
